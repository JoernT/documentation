<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng"
        schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml"
        schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>XQuery in eXist-db</title>
    <date>1Q18</date>
    <keywordset>
      <keyword>xquery</keyword>
    </keywordset>
  </info>

  <!-- ================================================================== -->

  <para>eXist-db provides strong support for the W3C recommendation of the XQuery language,
    implementing the XQuery and XPath functions and operators. eXist-db also builds
      <emphasis>on</emphasis> the recommendation, adding a rich family of extension functions and
    other capabilities, allowing XQuery developers to create powerful applications with
    eXist-db.</para>
  <para>This document is intended for advanced developers to understand eXist-db's implementation of
    XQuery. For readers who are new to XQuery or programming in general we recommend you start with
    the resources listed in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="learning-xquery">Learning XQuery with eXist-db</link> or <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="development-starter">Getting Started
      with Web Application Development</link>.</para>

  <!-- ================================================================== -->

  <sect1 xml:id="current-status-of-xquery-support">
    <title>Current Status of XQuery Support</title>

    <para>eXist-db implements the XQuery 3.1 language as specified in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/" condition="_blank">W3C recommendation</link>, with the exception of features <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#unsupported-features">detailed
        below</link>. </para>
    <para>Functions in the standard function library follow the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-functions/" condition="_blank">"XQuery 1.0 and XPath
        2.0 Functions and Operators" recommendation</link>. See also the eXist-db <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/exist/apps/fundocs" condition="_blank">XQuery Function Documentation</link>.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xqts">
      <title>XQuery Test Suite compliance</title>

      <para>The eXist-db XQuery implementation is tested against the official <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.w3.org/2006/xquery-test-suite/" condition="_blank">XML Query Test
          Suite (XQTS)</link>. </para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="supported-optional-features">
      <title>Supported Optional Features</title>

      <para>In addition to the standard features, eXist-db provides extended support for <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#module-system">
          <emphasis>modules</emphasis>
        </link>.</para>
      <para>It implements the <emphasis>full axis</emphasis> feature. This means you can use the
          <emphasis>optional axes</emphasis>: <literal>ancestor::</literal>,
          <literal>ancestor-or-self::</literal>, <literal>following::</literal>,
          <literal>following-sibling::</literal>, <literal>preceding::</literal> and
          <literal>preceding-sibling::</literal>. The only optional axis not supported is the
          <literal>namespace</literal> axis.</para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="unsupported-features">
      <title>Unsupported features</title>

      <para>The following features from the standard are not supported:</para>
      <itemizedlist>
        <listitem>
          <para>Schema-related Features (<literal>validate</literal> and <literal>import
              schema</literal>). eXist-db's XQuery processor does currently not support the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-schema-import-feature">schema
              import</link> and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-schema-validation-feature">schema
              validation features</link> (defined as <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-conform-optional-features" condition="_blank">optional</link> in the XQuery specification). Instead eXist-db
            provides <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{fundocs}/view.html?uri=http://exist-db.org/xquery/validation&amp;location=java:org.exist.xquery.functions.validation.ValidationModule">extension functions</link> to perform XML validation. </para>
          <para>The database does not store type information along with the nodes. It therefore
            cannot know the typed value of a node and has to assume
              <literal>xs:untypedAtomic</literal> (as defined by the XQuery specification).</para>
        </listitem>
        <listitem>
          <para>eXist-db does not support specifying a data type in an element or attribute test.
            The node test <literal>element(test-node)</literal> is supported, but the test
              <literal>element(test-node, xs:integer)</literal> will result in a syntax
            error.</para>
        </listitem>
      </itemizedlist>
      <para>However, eXist-db supports strong typing whenever the expected type of an expression, a
        function argument or function return value is explicitly specified or can be known
        otherwise.</para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xquery-30">
      <title>XQuery 3.1 Support</title>

      <para>Some highlights and examples of eXist-db's XQuery 3.1 support:</para>
      <variablelist>
        <varlistentry>
          <term>Higher Order Functions</term>
          <listitem>
            <para>eXist-db completely supports higher-order functions, including features like
              inline functions, closures, and partial function application. For more information:
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/blogs/eXist/HoF" condition="_blank">Higher-Order Functions in XQuery 3.0</link>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
                        <code>group by</code> clause in FLWOR expressions</term>
          <listitem>
            <para>
                            <code>group by</code> provides an efficient way to group the sequences generated
              in a FLWOR expression. For example,</para>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-1.txt"/>
            <para>This queries the Shakespeare plays and groups the result by speaker.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
                        <code>try</code>/<code>catch</code>
                    </term>
          <listitem>
            <para>The <code>try</code>/<code>catch</code> expression provides error handling for
              dynamic and type errors. For example: </para>
            <programlisting language="xquery">try { 'a' + 7 } catch * { concat($err:code, ": ", $err:description) }</programlisting>
            <para>This returns the full error: </para>
            <programlisting>err:XPTY0004: It is a type error if...</programlisting>
            <para>For more information: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/HowTo/XQuery3/Try-CatchExpression" condition="_blank">Try-Catch Expression</link>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>String concatenation using <code>||</code>
                    </term>
          <listitem>
            <para>A convenient alternative to the <literal>concat()</literal> function is the
                <code>||</code> operator.</para>
            <para>For example, </para>
            <programlisting language="xquery">"Hello " || $world || "!"</programlisting>
            <para> is equivalent to </para>
            <programlisting language="xquery">concat("Hello", $world, "!")</programlisting>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Simple Map Operator <code>!</code>
                    </term>
          <listitem>
            <para>This be used to replace short "for" loops, providing performance benefits due to
              its simpler processing. For instance: </para>
            <programlisting language="xquery">("red", "blue", "green") ! string-length() ! (. * 2)</programlisting>
            <para>Here the right-hand expression is evaluated once for each item in the sequence to
              the left of the <code>!</code>. The result will be <code>6, 8, 10</code>: </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Switch expressions</term>
          <listitem>
            <para>Eliminates the need for long conditional chains of <code>if</code> clauses when
              comparing string values. See <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/HowTo/XQuery3/SwitchExpressionExample" condition="_blank">Switch Expression</link>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New functions</term>
          <listitem>
            <para>XPath 3.0 adds a number of functions, for instance for date and time formatting,
              number formatting, string analysis, etc.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Private functions and function annotations</term>
          <listitem>
            <para>Annotations declare properties associated with functions and variables. For
              example, functions can be declared as <code>%private</code> or <code>%public</code>.
              See the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-annotations" condition="_blank">specification</link>. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Serialization Parameters</term>
          <listitem>
            <para>XQuery 3.1 provides a standard way to set serialization parameters. The old,
              non-standard, approach in eXist-db was to use a single option with all parameters in
              its value: </para>
            <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
            <para>In XQuery 3.1 this is standardized to: </para>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-10.txt"/>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Maps and Arrays</term>
          <listitem>
            <para>Maps are fundamental for the templating module and other libraries and are
              therefore well supported. Over time, the specification changed slightly and so did the
              implementation in eXist. For example, to keep backwards compatibility, eXist allows
              the older notation in map constructors: <code>key:=value</code> in addition to the new
              one, <code>key: value</code>. Also, some functions in eXist support collations, which
              are no longer in the specification.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>To make use of these features, use the proper version declaration in the prolog of your
        queries:</para>
      <programlisting>xquery version "3.0";</programlisting>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>Missing Features</title>

      <para>eXist-db does not support some of the less frequently used XQuery 3.0 constructs, mainly
        because we did not encounter many use cases for them yet:</para>
      <itemizedlist>
        <listitem>
          <para>"tumbling" and "sliding window" in FLWOR expressions</para>
        </listitem>
        <listitem>
          <para>"count" clause in FLWOR expressions</para>
        </listitem>
        <listitem>
          <para>"allowing empty" in FLWOR clause</para>
        </listitem>
      </itemizedlist>
      <para>The following functions from the XQuery 3.0 function specification are missing as well.
        However, most of them are replacements for functions which are available in eXist-db's
        function library: </para>
      <table>
        <title>Unsupported XQuery 3.0 Functions</title>

        <tgroup cols="2">
          <colspec colname="c1" colnum="1" colwidth="1.0*"/>
          <colspec colname="c2" colnum="2" colwidth="1.0*"/>
          <thead>
            <row>
              <entry>
                <para>XQuery 3.0</para>
              </entry>
              <entry>
                <para>eXist-db</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>unparsed-text</para>
              </entry>
              <entry>
                <para>util:binary-to-string(util:binary-doc($doc))</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unparsed-text-available</para>
              </entry>
              <entry>
                <para>util:binary-doc-available</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unparsed-text-lines</para>
              </entry>
              <entry>
                <para>na</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>innermost/outermost</para>
              </entry>
              <entry>
                <para>na</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>path</para>
              </entry>
              <entry>
                <para>na</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>


    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="related-specifications">
      <title>Other Related Specifications</title>

      <variablelist>
        <varlistentry>
          <term>Full Text Search</term>
          <listitem>
            <para>eXist-db has an implementation-specific <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="lucene.xml">Full Text Search
                facility</link>, built on the Lucene library (among several methods of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="indexing.xml">indexing</link>). It does currently not support the W3C defined syntax.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>XQuery Update</term>
          <listitem>
            <para>eXist-db has an implementation-specific <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="update_ext.xml">XQuery Update
                syntax</link>. It does currently not support the official W3C syntax for this. </para>
            <para>The main difference is the eXist-db implementation supports in-place updates.
              Switching to the W3C recommendation would break backwards compatibility.</para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="function-library">
    <title>Function Library</title>

    <para>A complete list of XQuery functions supported by eXist-db can be found in the XQuery
      function documentation. </para>
    <para>Each module's documentation is generated from a different sources, depending on whether
      the module is implemented in Java or XQuery. For modules implemented in Java, the
      documentation is taken directly from the signature provided by the class implementing the
        <literal>Function</literal> interface. For modules implemented in XQuery, the function
      descriptions are taken from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="xqdoc.xml">XQDoc-formatted comments and annotations</link>.</para>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="module-system">
    <title>The Module System</title>

    <para>eXist-db allows writing <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="development-starter.xml">web applications in XQuery</link>. This can result in
      complex XQuery scripts, consisting of several thousand lines of code. Packaging related
      functions in modules is therefore an important feature. eXist-db allows modules to be imported
      from a variety of sources:</para>
    <itemizedlist>
      <listitem>
        <para>an URI</para>
      </listitem>
      <listitem>
        <para>a collection in the database</para>
      </listitem>
      <listitem>
        <para>a jar file, i.e. a Java archive</para>
      </listitem>
      <listitem>
        <para>a Java class, if the module is implemented in Java itself</para>
      </listitem>
    </itemizedlist>

    <para>For example, a typical import statement in an XQuery will look like this:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-12.txt"/>
    <para>Provided the module namespace does not point to one of the preloaded standard modules (see
      below), the query engine will try to locate the module source by looking at the URI given
      after the <literal>at</literal> keyword. In the example above, the module was specified using
      a full URI and the query engine will attempt to load the module source from there. </para>
    <para>However, the module could also be stored in a database collection:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-13.txt"/>
    <para>The query engine recognizes the module is stored in the local database instance and tries
      to load it from there.</para>
    <para>If the XQuery module is part of a Java application, it is also an option to pack the
      module into a Java archive (<code>.jar</code> file) along with the Java classes. Then use the
      following <code>import</code> to load it:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-14.txt"/>
    <para>Finally, XQuery modules can also be implemented in Java (see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#calling-java">below</link>).You can
      import them by specifying the class path of the Module class:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-15.txt"/>
    <para>The <literal>extensions/modules</literal> directory in the eXist-db distribution contains
      a number of useful modules. These can also serve as examples for implementing your own.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>Using Relative URIs</title>

      <para>If the location specified in an import statement is a relative URI, the query engine
        tries to load the module relatively to the current module load path. The module load path is
        determined as follows:</para>
      <orderedlist>
        <listitem>
          <para>If the main XQuery was loaded from a database collection, the module load path is
            the URI of that collection. For example if you access an XQuery via the REST
            server:</para>
          <programlisting>http://localhost:8080/exist/servlet/db/modules/test.xq</programlisting>
          <para>Now all relative module paths will be resolved relative to the
              <literal>/db/modules</literal> collection.</para>
        </listitem>
        <listitem>
          <para>If the main XQuery was retrieved from the file system, the module load path points
            to that directory. This applies to queries executed through the XQueryServlet,
            XQueryGenerator or the Java admin client.</para>
        </listitem>

      </orderedlist>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>Preloaded Modules</title>

      <para>Preloaded modules do not need to be explicitly imported or declared in the prolog of
        queries. The <tag>builtin-modules</tag> element in <literal>conf.xml</literal> lists the
        namespaces and the corresponding Java class that implements all modules to be
        preloaded:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xml" xlink:href="listings/listing-17.xml"/>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="xquery-caching">
    <title>XQuery Caching</title>

    <para>XQuery modules executed via the REST interface, the XQueryServlet or XQueryGenerator are
        <emphasis>automatically</emphasis> cached. The compiled expression will be added to an
      internal pool of prepared queries. Next time a query or module is loaded from the same
      location, the already compiled code is reused. The code will only be recompiled if eXist-db
      decides that the source was modified or when it wasn't used for a longer period of
      time.</para>
    <para>If a query is accessed by more than one thread concurrently, each new thread will create a
      new copy of the compiled query. The copies will be added to the query pool until it reaches a
      pre-defined limit.</para>
    <para>Modules are cached along with the main query that imported them.</para>
  </sect1>


  <!-- ================================================================== -->

  <sect1 xml:id="calling-java">
    <title>Calling Java Methods from XQuery</title>

    <para>eXist-db supports calls to arbitrary Java methods from within XQuery. The binding
      mechanism follows the short-cut technique introduced by <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://saxon.sf.net" condition="_blank">Saxon</link>.</para>
    <para> The class of the external function is identified by the namespace URI of the function
      call. This namespace URI must start with the prefix <literal>java:</literal>, followed by the
      fully qualified class name of the class. For example, the following code snippet calls the
      static method <literal>sqrt</literal> (square-root) of class
      <literal>java.lang.Math</literal>:</para>

    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-18.txt"/>
    <para>If the function name contains a hyphen, the letter following the hyphen is converted to
      upper-case and the hyphen is removed (to conform to the Java CamelCase naming convention). So
      for example, <code>to-string()</code> will call the Java method
      <code>toString()</code>.</para>
    <para>If more than one method in the class matches the given name and parameter count, eXist-db
      tries to select the method that best fits the passed parameter types at runtime. </para>
    <para>The result of the method call can be assigned to an XQuery variable. If possible, it will
      be mapped to the corresponding XML schema type. Otherwise, it's type is the eXist-db built-in
      type <literal>object</literal>.</para>
    <para>
      <emphasis>Java constructors</emphasis> are called using the function <literal>new</literal>.
      Again, a matching constructor is selected by looking at the parameter count and types. The
      returned value is a new Java object with the built-in type <literal>object</literal>.</para>
    <para>
      <emphasis>Instance methods</emphasis> are called by supplying a valid Java object as first
      parameter. The Java object has to be an instance of the given class. For example, the
      following snippet lists all files and directories in the current directory:</para>

    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-19.txt"/>
    <note>
      <para>For security reasons, the Java binding is disabled by default. To enable it, the
        attribute <literal>enable-java-binding</literal> in the central configuration file has to be
        set to <literal>yes</literal>: </para>
      <programlisting>&lt;xquery enable-java-binding="yes"&gt;</programlisting>
      <para>Enabling the Java binding bears some risks: if you allow users to directly pass XQuery
        code to the database, for instance through the sandbox application, they can use Java
        methods to inspect your system or execute potentially destructive code on the server.</para>
    </note>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="modules">
    <title>Creating XQuery Modules</title>

    <para>eXist-db supports XQuery library modules, collections of function definitions and global
      variable declarations. eXist-db distinguishes two types: <emphasis>External
      Modules</emphasis>, written in XQuery and <emphasis>Internal Modules</emphasis>, implemented
      in Java. The standard XPath/XQuery functions and all standard eXist-db extension functionsare
      implemented as internal modules. This section describes how to create XQuery modules using
      XQuery and Java.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xquery-modules">
      <title>Creating Modules in XQuery</title>

      <para>You can declare an XQuery file as a module and import it using the <literal>import
          module</literal> directive. The XQuery engine imports each module only once during
        compilation. The compiled module is made available through the static XQuery context.</para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="java-modules">
      <title>Creating Modules in Java</title>

      <para>To register Java-based XQuery modules, eXist-db requires a namespace URI to identify it
        and the list of functions it supplies. For this, you need to pass a driver class to the
        XQuery engine. This class must implement the interface
          <literal>org.exist.xpath.InternalModule</literal>.</para>
      <note>
        <para>Besides the basic methods for creating a Java-based XQuery module described here,
          eXist-db provides a pluggable module interface that allows extension modules to be easily
          developed in Java. See <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="extensions.xml">XQuery Extension Modules</link> for the full documentation
          on this eXist-db development best practice.</para>
      </note>
      <para>The class <literal>org.exist.xpath.AbstractInternalModule</literal> already provides an
        implementation skeleton. The class constructor expects an array of function definitions for
        all functions to registered. A function definition (class <literal>FunctionDef</literal>)
        has two properties: the static signature of the function (as an instance of
          <literal>FunctionSignature</literal>) and the Java Class that implements the
        function.</para>
      <para>A function is a class extending <literal>org.exist.xquery.Function</literal> or
          <literal>org.exist.xquery.BasicFunction</literal>. Functions without special requirements
        (like overloading) should subclass BasicFunction. To illustrate this a simple function
        definition:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="java" xlink:href="listings/listing-21.txt"/>
      <itemizedlist>
        <listitem>
          <para>Note that every function class has to provide a function
              <emphasis>signature</emphasis>. This defines the <emphasis>QName</emphasis> by which
            the function is identified, a documentation string, the sequence types of all arguments
            and the sequence type of the returned value. </para>
          <para>In the example above, we accept a single argument named "text" of type
              <literal>xs:string</literal> and a cardinality of <literal>ZERO_OR_MORE</literal> with
            the description "The text to echo". In other words, we accept any sequence of strings
            containing zero or more items. The return value is of type <literal>xs:string</literal>
            and a cardinality of <literal>ZERO_OR_MORE</literal> with the description "the echoed
            text". </para>
          <para>A parameter description should be normal sentence starting with a capital letter.
            The return value description is always prefixed with "Returns ", so make sure the text
            matches. </para>
        </listitem>
        <listitem>
          <para>The subclass overwrites the <literal>eval</literal> method, which has two arguments:
            the first contains the values of all arguments passed to the function, the second passes
            the current context sequence (which might be <code>null</code>). </para>
          <para>Note that the argument values in the array <literal>args</literal> have already been
            checked to match the sequence types defined in the function signature. We therefore do
            not have to recheck the length of the array: if more or less than one argument were
            passed to the function, an exception would have been thrown before <code>eval</code>
            gets called.</para>
          <para>In XQuery, all values are passed as sequences. A sequence consists of one or more
            items, and every item is either an atomic value or a node. Furthermore, a single item is
            also a sequence. The function signature specifies that any sequence containing zero or
            more strings is acceptable for our method. We therefore have to check if the empty
            sequence has been passed. Here the function call returns immediately. Otherwise, we
            iterate through each item in the sequence, prefix <literal>echo:</literal> to its string
            value, and add it to the result sequence.</para>
        </listitem>

      </itemizedlist>

      <para>Now we want to add the function to a new module, so we have to provide a
          <emphasis>driver class</emphasis>. The driver class defines the namespace URI and default
        prefix for the module. Functions are registered by passing an array of
          <literal>FunctionDef</literal> to the constructor. The following is an example driver
        class definition:</para>

      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="java" xlink:href="listings/listing-22.txt"/>
      <para>To use this in XQuery:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-23.txt"/>
      <para>The query engine recognizes the <literal>java:</literal> prefix in the location URI and
        treats the remaining part <literal>org.exist.examples.xquery.ExampleModule</literal> as a
        fully qualified class name leading to the driver class of the module.</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="collations">
    <title>Collations</title>

    <para>Collations are used to compare strings in a <emphasis>locale-sensitive</emphasis> fashion.
      XQuery allows to specify collations by means of a collation URI. For example, a collation can
      be specified in the <literal>order by</literal> clause of a XQuery FLWOR expression as well as
      in string-related functions. </para>
    <para>The concrete form of the URI is defined by the eXist-db implementation. Specifically,
      eXist-db recognizes the following collation URIs:</para>

    <variablelist>
      <varlistentry>
        <term>
                    <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>
                </term>
        <listitem>
          <para>This URI selects the unicode codepoint collation. This is default if no collation is
            specified. The standard Java implementations of the comparison and string search
            functions are used.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>http://exist-db.org/collation?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code>
                </term>
        <listitem>
          <para>Or in short: <code>?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code>
                    </para>
          <para>The <literal>lang</literal> parameter selects a locale, and should have the same
            form as in <literal>xml:lang</literal>. For example, "de" or "de-DE" to select the
            German locale.</para>
          <para>The optional <literal>strength</literal> parameter must be one of
              <code>primary</code>, <code>secondary</code>, <code>tertiary</code> or
              <code>identical</code>.</para>
          <para>The optional <code>decomposition</code> parameter (optional) has the value of
              <code>none</code>, <code>full</code> or <code>standard</code>.</para>
        </listitem>
      </varlistentry>
    </variablelist>


    <para>The following example selects the German locale for sorting:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-27.txt"/>
    <para>It returns the following:</para>
    <programlisting>Bauer, Bäuerin, Buch, Bücher, das, daß, Jagen, Jäger</programlisting>
    <para>You can change the default collation in the XQuery prolog:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-29.txt"/>
    <para>This now returns <literal>true</literal> (the default collation would have returned
        <literal>false</literal>).</para>
    <para>You can also use Java class specified collators. They should be subclassing
        <literal>java.text.RuleBasedCollator</literal>. For example:</para>
    <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-30.txt"/>
    <para>The <code>.jar</code> with the <code>.class</code> file(s) of the collator needs to be in
        <literal>${EXIST_HOME}/lib/user</literal>
    </para>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="serialization">
    <title>Serialization Options</title>

    <para>The serialization of query results into a binary stream is influenced by a number of
      parameters. These parameters can be set within the query itself. However the interpretation of
      the parameters depends on the context in which the query is called. Most output parameters are
      applicable only if the query is executed using the XQueryGenerator/XQueryServlet servlet or
      the REST server.</para>
    <para>In bygone days serialization parameters were implementation defined so eXist-db developed
      its own set of parameters. In XQuery 3.0, serialization is standardized.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="serialization-10">
      <title>eXist-db specific serialization</title>

      <para>Serialization parameters can be set with a <literal>declare option</literal> statement
        in the query prolog. For instance:</para>
      <programlisting>declare option exist:serialize "method=xhtml media-type=application/xhtml+html";</programlisting>


      <para> The option's QName must be <literal>exist:serialize</literal>. The
          <literal>exist</literal> prefix is bound to the namespace
          <literal>http://exist.sourceforge.net/NS/exist</literal>. This is declared by default and
        need not be specified explicitly.</para>
      <para>Options are specified within the option's string literal, separated by
        whitespace.</para>


      <para>General options:</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term>
            <literal>method= xml | xhtml | json | text</literal>
          </term>
          <listitem>
            <para>Determines the serialization method. Should be one of <code>xml</code>,
                <code>xhtml</code>, <code>json</code> or <code>text</code>. </para>
            <para>The <code>xhtml</code> method makes sure that XHTML elements with an empty content
              model are serialized in minimized form. For instance <tag>img</tag> will be output as
                <tag>img/</tag>. </para>
            <para>Unlike the <code>xml</code> method, the <code>xhtml</code> setting uses only the
              short form for the elements declared empty in the xhtml DTD. For example, the
                <tag>br</tag> tag is always returned as <code>&lt;br/&gt;</code>. </para>
            <para>The <code>text</code> method returns the contents of elements only. For instance,
                <code>&lt;A&gt;Content&lt;/A&gt;</code> is returned as <literal>Content</literal>.
              Attribute values, processing instructions and comments are ignored.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>jsonp= myFunctionName</literal>
          </term>
          <listitem>
            <para>Only relevant when the serialization method is set to <code>json</code>. Causes
              the JSON output to be wrapped in the named JSONP function. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>media-type</literal>
          </term>
          <listitem>
            <para>The MIME content type of the output. It will be used to set the HTTP
                <code>Content-Type</code> header if the query is running in an HTTP context.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>encoding</literal>
          </term>
          <listitem>
            <para>Specifies the character encoding to be used for outputting the instance of the
              data model</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>doctype-public</literal> and <literal>doctype-system</literal>
          </term>
          <listitem>
            <para>a doctype declaration will be output if <code>doctype-public</code> and/or
                <code>doctype-system</code> are set. The corresponding identifier is taken from the
              value of the parameter.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>indent= yes | no</literal>
          </term>
          <listitem>
            <para>Indent the document to make it easier to read. Indenting adds whitespace
              characters to element nodes, restricted by the rules given in the XQuery serialization
              specification.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>omit-xml-declaration= yes | no</literal>
          </term>
          <listitem>
            <para>Output an XML declaration if the parameter is set to <code>no</code>
                        </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>eXist-db specific options:</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term>
            <literal>expand-xincludes= yes | no</literal>
          </term>
          <listitem>
            <para>Must the serializer expand XInclude elements?</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>highlight-matches= both | elements | attributes | none</literal>
          </term>
          <listitem>
            <para>When querying text with the full text or n-gram extensions, the query engine
              tracks the exact position of all matches inside text content. The serializer can later
              use this information to mark those matches by wrapping them into an
                <tag>exist:match</tag> element.</para>
            <para>Setting <literal>highlight-matches=both</literal> will enable this feature for
              every kind of indexable node.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>process-xsl-pi= yes | no</literal>
          </term>
          <listitem>
            <para>If a document is serialized and it has an XSL processing instruction, eXist-db can
              try to load the referenced stylesheet and apply it to the document.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>add-exist-id= element | all | none</literal>
          </term>
          <listitem>
            <para>Shows the internal node ids of an element by adding an attribute
                <literal>exist:id="internal-node-id"</literal>. Setting add-exist-id to
                <code>element</code> will only show the node id of the top-level element,
                <code>all</code> will show the ids of all elements.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>json-ignore-whitespace-text-nodes= yes | no</literal>
          </term>
          <listitem>
            <para>To discard white-space text nodes when serializing XML/XDM to JSON.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>For example, to disable XInclude expansion and indent the output, use the following
        syntax:</para>
      <programlisting>declare option exist:serialize "expand-xincludes=no indent=yes";</programlisting>


    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="serialization-30">
      <title>Serialization in XQuery 3.0</title>

      <para>XQuery 3.0 provides a standard way to set serialization parameters. For example:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-34.txt"/>
      <para>This is equivalent to the eXist-db specific serialization setting:</para>
      <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
      <para>The eXist-db specific approach remains supported for backwards compatibility
        reasons.</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="other-options">
    <title>Query Blocking Options</title>

    <para>To prevent the server from being blocked by a badly formulated query, eXist-db watches all
      query threads. A blocking query can be killed if it takes longer than a specified amount of
      time or consumes too many memory resources on the server. There are two options to control
      this behaviour:</para>
    <variablelist>
      <varlistentry>
        <term>
                    <code>declare option exist:timeout "time-in-ms";</code>
                </term>
        <listitem>
          <para>Specifies the maximum amount of query processing time (in milliseconds) before it is
            cancelled by the XQuery engine.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>declare option exist:output-size-limit "size-hint";</code>
                </term>
        <listitem>
          <para>Defines a limit for the maximum size of a document fragment created within an
            XQuery. The limit is just an estimation, specified in terms of the accumulated number of
            nodes contained in all generated fragments. This can be used to prevent users from
            consuming too much memory if they are allowed to pass in their own XQueries.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <!-- ================================================================== -->

  <sect1>
    <title>Other options</title>

    <variablelist>
      <varlistentry>
        <term>
                    <code>declare option exist:implicit-timezone "duration";</code>
                </term>
        <listitem>
          <para>Specifies the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#dt-timezone" condition="_blank">implicit
              timezone</link> for the XQuery context.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>declare option exist:current-dateTime "dateTime";</code>
                </term>
        <listitem>
          <para>Specifies the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#GLdt-date-time" condition="_blank">current
              dateTime</link> for the XQuery context.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>declare option exist:optimize "enable=yes|no";</code>
                </term>
        <listitem>
          <para>Temporarily disables the query rewriting optimizer for the current query. Use for
            testing/debugging.</para>
        </listitem>
      </varlistentry>
    </variablelist>

  </sect1>
  
  <!-- ================================================================== -->
  
  <sect1 xml:id="pragmas">
    <title>Pragmas</title>
    
    <para>XQuery pragmas are a way to pass implementation-specific information to the query engine.
      Pragmas can be wrapped around an arbitrary XQuery expression.</para>
    
    <para>Currently, eXist-db recognizes the following pragmas:</para>
    
    <variablelist>
      <varlistentry>
        <term>
                    <code>exist:timer</code>
                </term>
        <listitem>
          <para>Provides a simple way to measure the time executing a given expression. For
            example:</para>
          <programlisting>(# exist:timer #) { //some/path/expression }</programlisting>
          <para>This creates a timer for the expression enclosed in curly braces and prints timing
            information to the trace logger. Tracing needs to be enabled in
            <literal>log4j.xml</literal>:</para>
          <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xml" xlink:href="listings/listing-36.xml"/>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>exist:batch-transaction</code>
                </term>
        <listitem>
          <para>
            <emphasis>Currently for XQuery Update Extensions only.</emphasis> Provides a method for
            batching updates on the database into a single transaction, allowing a set of updates to
            be atomically guaranteed. </para>
          <para>For each affected document or collection, any configured Triggers will only be
            called once, the <literal>prepare()</literal> method will be fired before the first
            update to the configured resource and the <literal>finish()</literal> method fired after
            the last update to the configured resource.</para>
          <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-37.txt"/>
          <para>Uses a single Transaction and Trigger events for the expressions enclosed in curly
            braces.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>exist:force-index-use</code>
                </term>
        <listitem>
          <para>
            <emphasis>For debugging purposes</emphasis>. Apply on an expression that uses indexes:
            comparisons, <literal>fn:matches()</literal>, etc. Will raise an error if, for any
            reason, the index cannot be used. This helps checking whether indexes are correctly
            defined or not.</para>
          <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-38.txt"/>
          <para>Raises an error if the general comparison doesn't use a range or a QName index
            (<code>XPDYxxxx</code>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>exist:no-index</code>
                </term>
        <listitem>
          <para>Prevents the query engine using any index. Useful if the searched value isn't very
            selective or if it is cheaper to traverse the previous step of a path expression than
            querying the index.</para>
          <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-39.txt"/>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
                    <code>exist:optimize</code>
                </term>
        <listitem>
          <para>This pragma is inserted automatically by the query rewriter to optimize an
            expression that implements the <literal>org.exist.xquery.Optimizable</literal>
            interface.</para>
          <programlisting>//((#exist:optimize#) { item[stock = 10] })</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>
    
  </sect1>
  
</article>